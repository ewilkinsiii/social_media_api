require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to test the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator. If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails. There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.

RSpec.describe '/api/v1/posts', type: :request do
  before(:each) do
    @user = create(:user)
  end

  scenario 'GET /api/v1/posts' do
    posts = create_list(:post, 10, user_id: @user.id)

    get '/api/v1/posts'
    expect(response).to have_http_status(:success)
    json = JSON.parse(response.body).deep_symbolize_keys
    data = json[:data]
    expect(data.size).to eq(10)
  end

  scenario 'GET /api/v1/posts/:id' do
    post = create(:post, user_id: @user.id)

    get "/api/v1/posts/#{post.id}"
    expect(response).to have_http_status(:success)

    json = JSON.parse(response.body).deep_symbolize_keys
    data = json[:data]

    user_relationship = data[:relationships][:user][:data]
    user_id_from_data = user_relationship[:id].to_i

    expect(data[:id]).to eq(post.id.to_s)
    expect(data[:attributes][:title]).to eq(post.title)
    expect(data[:attributes][:body]).to eq(post.body)
    expect(user_id_from_data).to eq(post.user_id)
  end

  scenario 'POST /api/v1/posts' do
    post_attributes = attributes_for(:post, user_id: @user.id)

    post '/api/v1/posts', params: { post: post_attributes }.to_json, headers: { 'Content-Type' => 'application/json' }
    expect(response).to have_http_status(:success)

    json = JSON.parse(response.body).deep_symbolize_keys
    data = json[:data]

    user_relationship = data[:relationships][:user][:data]
    user_id_from_data = user_relationship[:id].to_i

    expect(data[:id]).to be_present
    expect(data[:attributes][:title]).to eq(post_attributes[:title])
    expect(data[:attributes][:body]).to eq(post_attributes[:body])
    expect(user_id_from_data).to eq(post_attributes[:user_id])
  end

  scenario 'PUT /api/v1/posts/:id' do
    post = create(:post, user_id: @user.id)
    title = Faker::Lorem.characters(number: 10)
    post_attributes = attributes_for(:post, title: title, user_id: @user.id)

    put "/api/v1/posts/#{post.id}", params: { post: post_attributes }.to_json,
                                    headers: { 'Content-Type' => 'application/json' }
    expect(response).to have_http_status(:success)

    json = JSON.parse(response.body).deep_symbolize_keys
    data = json[:data]

    user_relationship = data[:relationships][:user][:data]
    user_id_from_data = user_relationship[:id].to_i

    expect(data[:id]).to eq(post.id.to_s)
    expect(data[:attributes][:title]).to eq(post_attributes[:title])
    expect(data[:attributes][:body]).to eq(post_attributes[:body])
    expect(user_id_from_data).to eq(post_attributes[:user_id])
  end

  scenario 'DELETE /api/v1/posts/:id' do
    post = create(:post, user_id: @user.id)

    delete "/api/v1/posts/#{post.id}"
    expect(response).to have_http_status(:success)
    expect(response.body).to be_empty
  end
end
